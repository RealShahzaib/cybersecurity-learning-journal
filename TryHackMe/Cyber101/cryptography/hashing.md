# üîê Hashing ‚Äì Concepts, Password Security & Practical Understanding

## üß† Initial Understanding ‚Äì What is Hashing?

When I first got introduced to hashing, I learned that a **hash value** is a fixed-size string that is generated by a hash function.

A hash function:
- Takes input of any size (text, file, password, etc.)
- Produces a fixed-length output (hash)

In simpler terms, hashing is a way to transform data into a unique-looking output without using any key, which makes it different from encryption.

Unlike encryption:
- Encryption = reversible (with a key)
- Hashing = one-way (cannot realistically be reversed)

This made me realize that hashing is not meant to ‚Äúhide‚Äù data like encryption, but rather to **verify data integrity and authenticity**.

---

## üîç Why Hashing is Powerful (Integrity & Verification)

One of the most important realizations I had was how hashing helps in **data integrity**.

For example:
- If a password is stored as a hash
- The system never checks the plain password
- Instead, it hashes the entered password and compares hash values

If even **one bit changes** in the input, the hash output becomes completely different.

I actually tested this myself:
- Compared letters like `T` and `U`
- Checked their hexdump (very small binary difference)
- But their hash values (using `md5sum`) were completely different

This showed me the **avalanche effect** of hashing, where tiny input changes produce drastically different outputs.

---

## üßÆ Different Hashing Algorithms

Another thing I observed was that:
> The same input produces different outputs with different hashing algorithms.

For example:
- MD5
- SHA-1
- SHA-256
- Bcrypt
- Argon2

Even with the same text input, each algorithm generates a totally different hash value.

This helped me understand why choosing a **secure hashing algorithm** matters in real-world security.

---

## ‚ö†Ô∏è Hash Collisions & Security Concerns

While learning more, I came across the concept of **hash collisions**.

A collision happens when:
> Two different inputs produce the same hash output.

I related this to the pigeonhole principle:
- Infinite inputs
- Fixed-size outputs
- So collisions are theoretically unavoidable

Older algorithms like:
- MD5
- SHA-1  

are now considered insecure because attackers can **engineer collisions**.

This makes them unsuitable for modern password storage and security systems.

---

## üîë Hashing in Password Storage (Real-World Use)

One major use of hashing is in **password authentication**.

Instead of storing plaintext passwords:
- The system stores only the hash
- During login, the entered password is hashed
- The hash is compared with the stored hash

Important realization:
> The system never needs to know the actual password in plaintext.

This is also why hashing is different from password managers, which can sometimes retrieve stored passwords.

---

## üí• Real-World Data Breaches (Bad Password Practices)

### 1Ô∏è‚É£ Storing Passwords in Plaintext ‚Äì RockYou Breach
I learned about the RockYou breach where passwords were stored in plaintext.  
Over **14 million passwords** were leaked, which later became the famous `rockyou.txt` wordlist used in password cracking.

This showed how dangerous plaintext storage is.

---

### 2Ô∏è‚É£ Insecure Encryption ‚Äì Adobe Breach
In Adobe‚Äôs breach, passwords were not securely hashed and some hints were stored in plaintext.  
This made it easier for attackers to recover actual passwords.

It made me realize that:
> Weak encryption or bad storage design can defeat security entirely.

---

### 3Ô∏è‚É£ Weak Hashing ‚Äì LinkedIn (2012)
LinkedIn used SHA-1 without salting for password storage.  
Since SHA-1 is now insecure and no salting was used, millions of passwords were cracked after the breach.

---

## üßÇ Password Salting ‚Äì Solving the Same Password Problem

I then understood a major issue:
> If two users have the same password, their hash will also be the same.

This becomes dangerous during database leaks because:
- If one hash is cracked
- Multiple accounts using the same password are compromised

The solution to this is **Password Salting**.

Salting process:
1. Generate a unique random salt for each user
2. Combine password + salt
3. Hash the combined value
4. Store both the salt and hash in the database

Now even if two users have the same password:
- Their salts are different
- Their final hashes will be completely different

This also protects against **rainbow table attacks**, where attackers use precomputed hash databases.

---

## üõ°Ô∏è Best Practice for Secure Password Storage

From my learning and labs, the best approach is:
- Use a strong hashing algorithm (Argon2, bcrypt, yescrypt)
- Generate a unique salt per user
- Hash (password + salt)
- Store the hash and salt securely

I even practiced storing some sample passwords using salted hashing to understand the workflow better.

---

## üêß Linux Password Hashing & Shadow File
I also explored how Linux stores passwords in the `/etc/shadow` file.

Format example: ```username:$prefix$options$salt$hash```


Key observations:
- Fields are separated by `:`
- Prefix indicates hashing algorithm (bcrypt, yescrypt, etc.)
- Passwords are never stored in plaintext

This gave me real insight into how operating systems handle authentication securely.

---

## ü™ü Windows Hashing (NTLM & SAM)

On Windows systems:
- Password hashes are stored in the SAM (Security Accounts Manager)
- Uses NTLM hashing (based on MD4)

However, I also learned that tools like Mimikatz can extract these hashes if a system is compromised, which highlights the importance of endpoint security.

---

## üîì Password Cracking Tools (Hands-On)

I got introduced to:
- John the Ripper
- Hashcat

In one of my practical tasks:
- I was given password hashes
- Identified the hash type (using format/prefix)
- Checked if salt was present
- Used `hashcat` with `rockyou.txt` wordlist
- Successfully cracked the passwords

This helped me understand how weak passwords and poor hashing practices are exploited in real attacks.

---

## üì¶ Hashing for File Integrity Verification

Another practical use of hashing is file verification.

When downloading files:
- The original hash is provided
- I can generate the hash of the downloaded file
- If both hashes match ‚Üí file integrity is confirmed

This ensures the file was not modified or tampered with.

---

## üîè HMAC ‚Äì Hash + Secret Key

Finally, I learned about **HMAC (Hash-based Message Authentication Code)**.

HMAC:
- Combines a hash function with a secret key
- Ensures authenticity and integrity of messages
- Confirms that the message was not modified during transmission

This is commonly used in secure APIs, authentication systems, and network protocols.

---

## üìö Final Reflection

This hashing module really changed my perspective on cybersecurity.  
I understood that hashing is not just a theory topic but a **core mechanism behind password security, integrity verification, and authentication systems**.

Doing hands-on tasks like:
- md5sum comparisons
- hash identification
- hashcat cracking
- shadow file analysis  

made the concepts much more practical and memorable rather than just theoretical learning.

I also explored how Linux stores passwords in the `/etc/shadow` file.

Format example:
